"use strict";const app=require("../shared/langchainjs.408ee1d5.cjs");require("path"),require("tty"),require("util"),require("fs"),require("net"),require("events"),require("stream"),require("zlib"),require("buffer"),require("string_decoder"),require("querystring"),require("url"),require("http"),require("crypto"),require("os"),require("typeorm"),require("https"),require("assert"),require("node:fs/promises"),require("node:path");const HUB_PATH_REGEX=/lc(@[^:]+)?:\/\/(.*)/,URL_PATH_SEPARATOR="/",loadFromHub=async(u,e,t,n,r={})=>{const i=u.match(HUB_PATH_REGEX);if(!i)return;const[o,s]=i.slice(1),a=o?o.slice(1):process.env.LANGCHAIN_HUB_DEFAULT_REF??"master";if(s.split(URL_PATH_SEPARATOR)[0]!==t)return;if(!n.has(app.extname(s).slice(1)))throw new Error("Unsupported file type.");const h=[process.env.LANGCHAIN_HUB_URL_BASE??"https://raw.githubusercontent.com/hwchase17/langchain-hub/",a,s].join("/"),l=await app.fetchWithTimeout(h,{timeout:5e3});if(l.status!==200)throw new Error(`Could not find file at ${h}`);return e(await l.text(),s,r)};class TextSplitter{constructor(e){if(Object.defineProperty(this,"chunkSize",{enumerable:!0,configurable:!0,writable:!0,value:1e3}),Object.defineProperty(this,"chunkOverlap",{enumerable:!0,configurable:!0,writable:!0,value:200}),this.chunkSize=e?.chunkSize??this.chunkSize,this.chunkOverlap=e?.chunkOverlap??this.chunkOverlap,this.chunkOverlap>=this.chunkSize)throw new Error("Cannot have chunkOverlap >= chunkSize")}async createDocuments(e,t=[]){const n=t.length>0?t:new Array(e.length).fill({}),r=new Array;for(let i=0;i<e.length;i+=1){const o=e[i];for(const s of await this.splitText(o))r.push(new app.Document({pageContent:s,metadata:n[i]}))}return r}async splitDocuments(e){const t=e.map(r=>r.pageContent),n=e.map(r=>r.metadata);return this.createDocuments(t,n)}joinDocs(e,t){const n=e.join(t).trim();return n===""?null:n}mergeSplits(e,t){const n=[],r=[];let i=0;for(const s of e){const a=s.length;if(i+a>=this.chunkSize&&(i>this.chunkSize&&console.warn(`Created a chunk of size ${i}, +
which is longer than the specified ${this.chunkSize}`),r.length>0)){const c=this.joinDocs(r,t);for(c!==null&&n.push(c);i>this.chunkOverlap||i+a>this.chunkSize&&i>0;)i-=r[0].length,r.shift()}r.push(s),i+=a}const o=this.joinDocs(r,t);return o!==null&&n.push(o),n}}class RecursiveCharacterTextSplitter extends TextSplitter{constructor(e){super(e),Object.defineProperty(this,"separators",{enumerable:!0,configurable:!0,writable:!0,value:[`

`,`
`," ",""]}),this.separators=e?.separators??this.separators}async splitText(e){const t=[];let n=this.separators[this.separators.length-1];for(const o of this.separators){if(o===""){n=o;break}if(e.includes(o)){n=o;break}}let r;n?r=e.split(n):r=e.split("");let i=[];for(const o of r)if(o.length<this.chunkSize)i.push(o);else{if(i.length){const a=this.mergeSplits(i,n);t.push(...a),i=[]}const s=await this.splitText(o);t.push(...s)}if(i.length){const o=this.mergeSplits(i,n);t.push(...o)}return t}}class AnalyzeDocumentChain extends app.BaseChain{constructor(e){super(),Object.defineProperty(this,"inputKey",{enumerable:!0,configurable:!0,writable:!0,value:"input_document"}),Object.defineProperty(this,"outputKey",{enumerable:!0,configurable:!0,writable:!0,value:"output_text"}),Object.defineProperty(this,"combineDocumentsChain",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"textSplitter",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.combineDocumentsChain=e.combineDocumentsChain,this.inputKey=e.inputKey??this.inputKey,this.outputKey=e.outputKey??this.outputKey,this.textSplitter=e.textSplitter??new RecursiveCharacterTextSplitter}get inputKeys(){return[this.inputKey]}async _call(e){if(!(this.inputKey in e))throw new Error(`Document key ${this.inputKey} not found.`);const{[this.inputKey]:t,...n}=e,r=t,o={input_documents:await this.textSplitter.createDocuments([r]),...n};return await this.combineDocumentsChain.call(o)}_chainType(){return"analyze_document_chain"}static async deserialize(e,t){if(!("text_splitter"in t))throw new Error("Need to pass in a text_splitter to deserialize AnalyzeDocumentChain.");const{text_splitter:n}=t,r=await app.resolveConfigFromFile("combine_document_chain",e);return new AnalyzeDocumentChain({combineDocumentsChain:await app.BaseChain.deserialize(r),textSplitter:n})}serialize(){return{_type:this._chainType(),combine_document_chain:this.combineDocumentsChain.serialize()}}}class VectorDBQAChain extends app.BaseChain{get inputKeys(){return[this.inputKey]}constructor(e){super(),Object.defineProperty(this,"k",{enumerable:!0,configurable:!0,writable:!0,value:4}),Object.defineProperty(this,"inputKey",{enumerable:!0,configurable:!0,writable:!0,value:"query"}),Object.defineProperty(this,"outputKey",{enumerable:!0,configurable:!0,writable:!0,value:"result"}),Object.defineProperty(this,"vectorstore",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"combineDocumentsChain",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"returnSourceDocuments",{enumerable:!0,configurable:!0,writable:!0,value:!1}),this.vectorstore=e.vectorstore,this.combineDocumentsChain=e.combineDocumentsChain,this.inputKey=e.inputKey??this.inputKey,this.outputKey=e.outputKey??this.outputKey,this.k=e.k??this.k,this.returnSourceDocuments=e.returnSourceDocuments??this.returnSourceDocuments}async _call(e){if(!(this.inputKey in e))throw new Error(`Question key ${this.inputKey} not found.`);const t=e[this.inputKey],n=await this.vectorstore.similaritySearch(t,this.k),r={question:t,input_documents:n},i=await this.combineDocumentsChain.call(r);return this.returnSourceDocuments?{...i,sourceDocuments:n}:i}_chainType(){return"vector_db_qa"}static async deserialize(e,t){if(!("vectorstore"in t))throw new Error("Need to pass in a vectorstore to deserialize VectorDBQAChain");const{vectorstore:n}=t,r=await app.resolveConfigFromFile("combine_documents_chain",e);return new VectorDBQAChain({combineDocumentsChain:await app.BaseChain.deserialize(r),k:e.k,vectorstore:n})}serialize(){return{_type:this._chainType(),combine_documents_chain:this.combineDocumentsChain.serialize(),k:this.k}}static fromLLM(e,t,n){const r=app.loadQAStuffChain(e);return new this({vectorstore:t,combineDocumentsChain:r,...n})}}const loadChainFromFile=async(u,e,t={})=>{const n=app.parseFileConfig(u,e);return app.BaseChain.deserialize(n,t)},loadChain=async(u,e={})=>{const t=await loadFromHub(u,loadChainFromFile,"chains",new Set(["json","yaml"]),e);return t||app.loadFromFile(u,loadChainFromFile,e)},template=`Write a concise summary of the following:


"{text}"


CONCISE SUMMARY:`,DEFAULT_PROMPT=new app.PromptTemplate({template,inputVariables:["text"]}),loadSummarizationChain=(u,e={})=>{const{prompt:t=DEFAULT_PROMPT,combineMapPrompt:n=DEFAULT_PROMPT,combinePrompt:r=DEFAULT_PROMPT,type:i="map_reduce"}=e;if(i==="stuff"){const o=new app.LLMChain({prompt:t,llm:u});return new app.StuffDocumentsChain({llmChain:o,documentVariableName:"text"})}if(i==="map_reduce"){const o=new app.LLMChain({prompt:n,llm:u}),s=new app.LLMChain({prompt:r,llm:u}),a=new app.StuffDocumentsChain({llmChain:s,documentVariableName:"text"});return new app.MapReduceDocumentsChain({llmChain:o,combineDocumentChain:a,documentVariableName:"text"})}throw new Error(`Invalid _type: ${i}`)},question_generator_template=`Given the following conversation and a follow up question, rephrase the follow up question to be a standalone question.

Chat History:
{chat_history}
Follow Up Input: {question}
Standalone question:`,qa_template=`Use the following pieces of context to answer the question at the end. If you don't know the answer, just say that you don't know, don't try to make up an answer.

{context}

Question: {question}
Helpful Answer:`;class ConversationalRetrievalQAChain extends app.BaseChain{get inputKeys(){return[this.inputKey,this.chatHistoryKey]}constructor(e){super(),Object.defineProperty(this,"inputKey",{enumerable:!0,configurable:!0,writable:!0,value:"question"}),Object.defineProperty(this,"chatHistoryKey",{enumerable:!0,configurable:!0,writable:!0,value:"chat_history"}),Object.defineProperty(this,"outputKey",{enumerable:!0,configurable:!0,writable:!0,value:"result"}),Object.defineProperty(this,"retriever",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"combineDocumentsChain",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"questionGeneratorChain",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"returnSourceDocuments",{enumerable:!0,configurable:!0,writable:!0,value:!1}),this.retriever=e.retriever,this.combineDocumentsChain=e.combineDocumentsChain,this.questionGeneratorChain=e.questionGeneratorChain,this.inputKey=e.inputKey??this.inputKey,this.outputKey=e.outputKey??this.outputKey,this.returnSourceDocuments=e.returnSourceDocuments??this.returnSourceDocuments}async _call(e){if(!(this.inputKey in e))throw new Error(`Question key ${this.inputKey} not found.`);if(!(this.chatHistoryKey in e))throw new Error(`chat history key ${this.inputKey} not found.`);const t=e[this.inputKey],n=e[this.chatHistoryKey];let r=t;if(n.length>0){const a=await this.questionGeneratorChain.call({question:t,chat_history:n}),c=Object.keys(a);if(c.length===1)r=a[c[0]];else throw new Error("Return from llm chain has multiple values, only single values supported.")}const i=await this.retriever.getRelevantDocuments(r),o={question:r,input_documents:i,chat_history:n},s=await this.combineDocumentsChain.call(o);return this.returnSourceDocuments?{...s,sourceDocuments:i}:s}_chainType(){return"conversational_retrieval_chain"}static async deserialize(e,t){throw new Error("Not implemented.")}serialize(){throw new Error("Not implemented.")}static fromLLM(e,t,n={}){const{questionGeneratorTemplate:r,qaTemplate:i,...o}=n,s=app.PromptTemplate.fromTemplate(r||question_generator_template),a=app.PromptTemplate.fromTemplate(i||qa_template),c=app.loadQAStuffChain(e,{prompt:a}),h=new app.LLMChain({prompt:s,llm:e});return new this({retriever:t,combineDocumentsChain:c,questionGeneratorChain:h,...o})}}class RetrievalQAChain extends app.BaseChain{get inputKeys(){return[this.inputKey]}constructor(e){super(),Object.defineProperty(this,"inputKey",{enumerable:!0,configurable:!0,writable:!0,value:"query"}),Object.defineProperty(this,"outputKey",{enumerable:!0,configurable:!0,writable:!0,value:"result"}),Object.defineProperty(this,"retriever",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"combineDocumentsChain",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"returnSourceDocuments",{enumerable:!0,configurable:!0,writable:!0,value:!1}),this.retriever=e.retriever,this.combineDocumentsChain=e.combineDocumentsChain,this.inputKey=e.inputKey??this.inputKey,this.outputKey=e.outputKey??this.outputKey,this.returnSourceDocuments=e.returnSourceDocuments??this.returnSourceDocuments}async _call(e){if(!(this.inputKey in e))throw new Error(`Question key ${this.inputKey} not found.`);const t=e[this.inputKey],n=await this.retriever.getRelevantDocuments(t),r={question:t,input_documents:n},i=await this.combineDocumentsChain.call(r);return this.returnSourceDocuments?{...i,sourceDocuments:n}:i}_chainType(){return"retrieval_qa"}static async deserialize(e,t){throw new Error("Not implemented")}serialize(){throw new Error("Not implemented")}static fromLLM(e,t,n){const r=app.loadQAStuffChain(e);return new this({retriever:t,combineDocumentsChain:r,...n})}}exports.BaseChain=app.BaseChain,exports.ChatVectorDBQAChain=app.ChatVectorDBQAChain,exports.ConversationChain=app.ConversationChain,exports.LLMChain=app.LLMChain,exports.MapReduceDocumentsChain=app.MapReduceDocumentsChain,exports.SqlDatabaseChain=app.SqlDatabaseChain,exports.StuffDocumentsChain=app.StuffDocumentsChain,exports.loadQAChain=app.loadQAChain,exports.loadQAMapReduceChain=app.loadQAMapReduceChain,exports.loadQAStuffChain=app.loadQAStuffChain,exports.AnalyzeDocumentChain=AnalyzeDocumentChain,exports.ConversationalRetrievalQAChain=ConversationalRetrievalQAChain,exports.RetrievalQAChain=RetrievalQAChain,exports.VectorDBQAChain=VectorDBQAChain,exports.loadChain=loadChain,exports.loadSummarizationChain=loadSummarizationChain;
